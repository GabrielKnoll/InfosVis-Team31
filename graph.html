<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Example comment -->
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Informationsvisualisierung Team 31</title>
  <link rel="stylesheet" href="styles.css">
  <script src="https://d3js.org/d3.v4.js"></script>
</head>
<body>

    <!-- Add a svg area, empty -->
<div id="dataviz_scatterplot"></div>
</body>
</html>

<script>
    // set the dimensions and margins of the graph
    var margin = {top: 10, right: 30, bottom: 30, left: 60},
        width = 460 - margin.left - margin.right,
        height = 400 - margin.top - margin.bottom;
    
    // append the SVG object to the div with id dataviz_scatterplot
    var svg = d3.select("#dataviz_scatterplot")
        .append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom)
        .append("g")
        .attr("transform",
        "translate(" + margin.left + "," + margin.top + ")");
    
    //Read the data
    d3.csv("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/connectedscatter.csv", 
        // When reading the csv, I must format variables:
        function(d){
            return { date : d3.timeParse("%Y-%m-%d")(d.date), value : d.value }
        },
        // Scatterplot
        function(data) {

            // Add X axis
            var x = d3.scaleTime()
                .domain(d3.extent(data, d => d.date))
                .range([ 0, width ]);
            var xAxis = svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x).tickFormat(d3.timeFormat("%Y")));
            
            // Add Y axis
            var y = d3.scaleLinear()
                .domain([d3.min(data, d => d.value) - 100, d3.max(data, d => d.value + 100)])
                .range([ height, 0 ]);
            var yAxis = svg.append("g")
                .call(d3.axisLeft(y));
            
            // Add a clipPath: everything out of this area won't be drawn.
            var clip = svg.append("defs").append("SVG:clipPath")
                .attr("id", "clip")
                .append("SVG:rect")
                .attr("width", width )
                .attr("height", height )
                .attr("x", 0)
                .attr("y", 0);
            
            // Create the scatter variable: where both the circles and the brush take place
            var scatter = svg.append('g')
                .attr("clip-path", "url(#clip)")

            // Add the line
            scatter
                .append("path")
                .datum(data)
                .attr("fill", "none")
                .attr("stroke", "#d4d4d4")
                .attr("stroke-width", 1.5)
                .attr("d", d3.line()
                .x(d => x(d.date))
                .y(d => y(d.value))
                )
        
            // Add circles
            scatter
                .selectAll("circle")
                .data(data)
                .enter()
                .append("circle")
                .attr("cx", d => x(d.date))
                .attr("cy", d => y(d.value))
                .attr("r", 5)
                .attr("fill", "#2798e9")
            
            // Set the zoom and Pan features: how much you can zoom, on which part, and what to do when there is a zoom
            var zoom = d3.zoom()
                .scaleExtent([.5, 1.5])  // This control how much you can unzoom (x0.5) and zoom (x20)
                .translateExtent([[0, 0], [width, height]])
                .extent([[0, 0], [width, height]])
                .on("zoom", updateChart);
            
            // This add an invisible rect on top of the chart area. This rect can recover pointer events: necessary to understand when the user zoom
            scatter
            .append("rect")
                .attr("width", width)
                .attr("height", height)
                .style("fill", "none")
                .style("pointer-events", "all")
                .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')
                .call(zoom);
            // now the user can zoom and it will trigger the function called updateChart
            
            // A function that updates the chart when the user zoom and thus new boundaries are available
            function updateChart() {
            
                // recover the new scale
                var newX = d3.event.transform.rescaleX(x);
                var newY = d3.event.transform.rescaleY(y);
            
                // update axes with these new boundaries
                xAxis.call(d3.axisBottom(newX).tickFormat(d3.timeFormat("%Y")))
                yAxis.call(d3.axisLeft(newY))
            
                // update circle position
                scatter
                .selectAll("circle")
                .attr("cx", d => newX(d.date))
                .attr("cy", d =>  newY(d.value));

                scatter
                .select('path')
                .attr("x",d => newX(d.date))
                .attr("y",d => newY(d.date));
            }
    })
    </script>